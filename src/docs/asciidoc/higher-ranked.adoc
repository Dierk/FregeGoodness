[[higherranked]]
== Advanced Parametric Polymorphism

*Parametric polymorphism* is established in mainstream programming languages for quite some time, though the term is unknown to many. 
For example, in Java, it goes under the name *generic types*.

The basic idea is simple: in the declaration of functions and data (or methods and classes), 
types that need not be known exactly are given as *type variables*. 
Such type variables may be *introduced* at certain places, depending on the language. 
Also, Java for example, requires explicit introduction of type variables. 
Later, when the function or data is used,
those formal type variables are *instantiated* with concrete types (which could well be other type variables that are valid in the context).

Here is an example in Frege

.Traditional Haskell map function
[source,haskell]
----
map ∷ (a→b) → [a] → [b]   -- optional!
map f []     = []
map f (x:xs) = f x : map f xs

sqrs = map (^2) [1..10]
----

Here is an approximation of how this would look like in Java:

.Imagined Java map function
[source,java]
----
public static<A,B> List<B> map(Function<A,B> f, List<A> xxs) {
    // ... details omitted ...
}

static List<Integer> sqrs = <Integer, Integer>map(
	x -> x*x, 
	Arrays.asList(1,2,3,4,5,6,7,8,9,10));
----

Despite <<inference.adoc#inference,Frege type inference>> 
being able to infer the type of `map` entirely on its own, 
it is customary to provide it explicitly. 
(Tools like the eclipse plugin make this a one-click action.)

The point is that in Frege, the introduction of type variables can be implicit, 
and the instantiation of type variables is always invisible.
Nevertheless, it can be deduced that `map` is instantiated at type `(Int→Int) → [Int] → [Int]` on the right hand side of the definition of `sqrs`.
But because instantiation is invisible, 
many Haskell and Frege programmers don't even know that it exists at all.

Whereas the Java code shows clearly both 
the (mandatory) introduction of type variables in the method declaration 
as well as their instantiation. 
To be fair, meanwhile the Java compiler can infer many of those instantiations. 
It needs a hint sometimes, however,
where exactly it has to do that (the so called diamond operator `<>`).

.This chapter is not about syntactic convenience!
****
It is about two concepts that belong closely to parametric polymorphism but are less widely known:
_higher ranked types_ and _higher kinded types_. 
It is about what is missing in the parametric polymorphism provided by Java.
 
It should provide insight why noble and honourable efforts like FunctionalJava, HighJ, JavaSlang, and others are inherently limited in their abstraction capabilities by the language they build on.
****

=== When _generic_ is not polymorphic enough

Suppose you are browsing your code, and find expressions like the following again and again:

[source,haskell]
----
zip (drop n  somelist) (drop n  otherlist)
zip (reverse somelist) (reverse otherlist)
----

where the function applied to the lists is different each time, and belongs to the infinite set of functions of type

[source,haskell]
----
∀a.[a] → [a]  <1>
----
<1> For the sake of clarity, all types are written using explicit quantification in this article.

For example, the following functions have this type (or a type that is even more general):

[source,haskell]
----
reverse
tail
init
drop 10
take 20
id
----

The intent is clear: we want to combine two lists, but only after having applied *the same* transformation to both lists.
In short, what we have is

[source,haskell]
----
zip (f somelist) (f otherlist)
----

for some appropriate function `f`, and now we want to get rid of the parentheses and of course of the
repetition of `f` (remember that `f` could be a lengthy expression itself). 

It looks like we need a function `fzip`, such that we could write

[source,haskell]
----
fzip f somelist otherlist
----

A possible implementation that comes to mind would be:

[source,haskell]
---
fzip f [] [] = []
fzip f xs ys = zip (f xs) (f ys)
----

Indeed, what could be easier?

But wait! When we ask the REPL for the type of `fzip`, it tells us this:

[source,haskell]
----
∀a b.([a]->[b]) -> [a] -> [a] -> [(b,b)]
----

For some reason, it assumes our two lists to have the same element type!

But the expressions we wanted to refactor didn't have that restriction.
After all, the transformation functions we intent to use are generic in the list element type, so they do work on any list. 

Anyway, as it stands, applying the planned refactoring would result in type errors everywhere the types of the two lists are not equal.
So, what is wrong with our `fzip`? 

To understand the case, one needs to remember what has been said about instantiation above. 
In an expression like

[source,haskell]
----
fzip reverse ['a', 'b', 'c'] [1, 2, 3] 
----

at what type should `reverse` get instantiated? If we choose

[source,haskell]
----
[Char] → [Char]
----

it wont be able to reverse integer lists. And if we choose 

[source,haskell]
----
[Int] → [Int]
----

it wont be able to reverse the character list. 

But why is this instantiation needed at all? 
It is needed because of a restriction in the Hindley-Milner type system, which forms the base of the type systems of languages like ML, Haskell, F# and Frege. This restriction says
that lambda bound values (you can read this as "function arguments") are assumed to be _monomorphic_. 
And this needs to be so because otherwise type inference would become *undecidable*. 

### Ranking Types

Another way to put this is that type inference à la Hindley-Milner (in the following HM for short) can only deal with polymorphism of rank 1. 
Yet another way to put this is that rank 1 types are exactly those polymorphic types that a HM algorithm can infer. Practically, this means that in languages that obey strictly to HM, higher order functions can only take monomorphic functions or functions that are instantiated at a monomorphic type. To be blunt, our `fzip` can't be written in ML or F#!

If we have numbered ranks, there should also be rank 2 types. How would such a type look like? Well, a rank 2 type is a function type where a rank 1 type appears as argument, that is, left of the function array. Generall, a type of rank k is a function type that has a type of rank (k-1) in argument position.

Think about this for a moment! There is an infinite number of ranks, and each rank is inhabited by an infinite number of types. Isn't that great?

### Using Higher Ranked Types

Fortunately, while *type inference* is undecidable for higher ranked types, *type checking* is not.  The type checkers of GHC (with language extension `RankNTypes`) and Frege employ this fact
and allow polymorphic functions as arguments.
 
However, the type of a function that takes polymorphic arguments must be
annotated, or at least the polymorphic argument itself must be annotated accordingly, and type inference will do the rest.

Hence, the solution to our problem is simply to point out that we want our function to be polymorphic. We can do this by providing the following annotation for `fzip`:

[source,haskell]
----
fzip ∷ (∀ a.[a] → [a]) → [x] → [y] → [(x,y)]
----

The code for `fzip` stays the same!

Alternatively, we can write `fzip` like so:

[source,haskell]
----
fzip (f :: ∀a.[a] → [a]) xs ys = zip (f xs) (f ys)
----

though I find this much less readable.

We can now use `fzip` with a variety of functions. But the types of all of them need to be *at least as polymorphic* as the annotated type for `f`.

Here are some examples. I give the type of `f` as comment:

[source,haskell]
----
fzip id         [1..10] ['a'..'z']   -- ∀a. a  →  a
fzip (drop 3)   [1..10] ['a'..'z']   -- ∀a.[a] → [a]
fzip reverse    [1..10] ['a'..'z']   -- ∀a.[a] → [a]
fzip (map id)   [1..10] ['a'..'z']   -- ∀a.[a] → [a]
fzip tail       [1..10] ['a'..'z']   -- ∀a.[a] → [a]
fzip (const []) [1..10] ['a'..'z']   -- ∀a b.a → [b]
----

This is it. 
We will come back to this and discuss the shortcomings as well as possible improvements of the higher rank solution.

Meanwhile, here is some homework for the very interested:

* Why not be even more general and let the type of `f` be `∀a b.[a] → [b]`? (The last example hints at the reason.)
* (for true Java experts) Write `fzip` in Java without using casts or `@SuppressWarnings` so that it compiles without warnings! (Yes, it is possible.)

